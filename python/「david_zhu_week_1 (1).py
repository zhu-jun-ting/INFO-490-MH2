# -*- coding: utf-8 -*-
"""ã€ŒDavid_Zhu_Week_1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mvSdTBHe_mlS6-pOok23aJ1AY3vFHTwC
"""

simple = {
 "apples": 5,
 "pears": 2,
 "bananas": 12
}
for k in sorted(simple.keys()):
 print(k, simple[k])

simple = {"apples":5, "pears":2, "bananas":12}
for t in sorted(simple.items()):
 # t is a tuple
 # t[0] is the key,
 # t[1] is the value
 print(t[0], t[1])

simple = {"apples":5, "pears":2, "bananas":12}
def by_value(key):
 # the key is a string (e.g. 'apples')
 # return the count
 return simple[key]
for k in sorted(simple.keys(), key=by_value):
 print(k, simple[k])

simple = {"apples":5, "pears":2, "bananas":12}
def by_value(tuple_item):
 return tuple_item[1]
for t in sorted(simple.items(), key=by_value):
 print(t[0], t[1])

complex_map = {
 "apples": {"count": 12, "calories": 200},
 "pears": {"count": 2, "calories": 100},
 "bananas": {"count": 5, "calories": 300}
}
print(complex_map["apples"]["calories"])

complex_map = {
 "apples": {"count": 12, "calories": 200},
 "pears": {"count": 2, "calories": 100},
 "bananas": {"count": 5, "calories": 300}
}
def by_count(key):
 # note this function is accessing
 # a global variable (not good)!
 return complex_map[key]["count"]
for k in sorted(complex_map.keys(), key=by_count):
 print(k, complex_map[k])

def by_count(t):
 # t is a tuple
 # t[0] is the key
 # t[1] is the value
#  print(t)
#  print()
 print(t)
 data = t[1]
 return data["count"]
for v in sorted(complex_map.items(), key=by_count):
#  print(v)
  pass

complex_map = {
 "apples": {"count": 12, "calories": 200},
 "pears": {"count": 2, "calories": 100},
 "bananas": {"count": 5, "calories": 300}
}

for v in sorted(complex_map.items(), key=lambda item: item[1]["count"]):
 print(v)

print(complex_map.items())

for v in sorted(complex_map.items(), key=lambda item: item[1]['count']):
  print(v)

names = ["McIntosh", "Red Delicious", "Fuji", "Gala", "Ambrosia", "Honeycrisp", "Granny Smith"]
sweetness = [3, 5, 8, 6, 7, 7.5, 1]
tartness = [7, 1, 3, 1, 1, 8, 10]

apples = {}

for index in range(len(names)):
  apples[names[index]] = {"sweetness" : sweetness[index], "tartness" : tartness[index]}

print(apples)

def get_apples():
  apples = {}
  for index in range(len(names)):
    apples[names[index]] = {"sweetness" : sweetness[index], "tartness" : tartness[index]}
  return apples

print(get_apples())

def by_sweetness(item):
	return item[1]["sweetness"]

def by_tartness(item):
	return item[1]["tartness"]

def apple_sorting(apple_list, sort_method):
	return sorted(apple_list.items(), key=sort_method, reverse=True)

print(apple_sorting(get_apples(), by_sweetness))

data = {
 "apples": {"count": 12, "calories": 200},
 "pears": {"count": 2, "calories": 100},
 "bananas": {"count": 5, "calories": 300}
}

def sort_by_total_calories(data):
  result = []
  for item in sorted(data.items(), key=lambda item: item[1]["calories"] * item[1]["count"], reverse=True):
    result.append((item[0], item[1]["calories"] * item[1]["count"]))
  return result
   
 
print(sort_by_total_calories(data))

# SHORT ANSWERS
# 1. keys are indexes of each pair and the values are the actual data holder of information according to each key
# 2. by applying additional parameter of key to sorted function based on keys
# 3. by applying additional parameter of key to sorted function based on values of each key
# 4. items() give you the actual iterator of items within the dictionary
# 5. the helper function is a function you decide to use to add to help you resolve a difficult algorithm 
# 6. lambda function is a small annomynous function simply one in and out put only for saving namespaces 
# 